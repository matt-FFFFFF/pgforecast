<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ü™Ç PG Forecast ‚Äî Paragliding Weather</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<style>
  :root {
    --bg: #0f1419;
    --card: #1a2332;
    --border: #2d3748;
    --text: #e2e8f0;
    --muted: #718096;
    --accent: #4fd1c5;
    --good: #48bb78;
    --warn: #ecc94b;
    --bad: #f56565;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--text); overflow: hidden; }

  .header { padding: 0.75rem 1.5rem; display: flex; align-items: center; gap: 1rem; border-bottom: 1px solid var(--border); height: 50px; z-index: 10; position: relative; }
  .header h1 { font-size: 1.3rem; font-weight: 600; }
  .header h1 span { font-size: 1.6rem; }
  .header-actions { margin-left: auto; display: flex; gap: 0.5rem; }
  .header-btn { background: var(--card); border: 1px solid var(--border); color: var(--text); padding: 0.35rem 0.7rem; border-radius: 6px; cursor: pointer; font-size: 0.78rem; transition: all 0.15s; }
  .header-btn:hover { border-color: var(--accent); color: var(--accent); }
  .header-btn.active { background: rgba(79,209,197,0.15); border-color: var(--accent); color: var(--accent); }

  .layout { display: flex; height: calc(100vh - 50px); }

  .sidebar { width: 280px; overflow-y: auto; border-right: 1px solid var(--border); flex-shrink: 0; z-index: 5; background: var(--bg); }
  .sidebar-header { padding: 0.6rem 1rem; font-weight: 600; color: var(--muted); text-transform: uppercase; font-size: 0.7rem; letter-spacing: 0.05em; border-bottom: 1px solid var(--border); }

  .site-item { padding: 0.6rem 1rem; cursor: pointer; border-bottom: 1px solid var(--border); transition: background 0.15s; display: flex; align-items: center; justify-content: space-between; }
  .site-item:hover { background: rgba(79, 209, 197, 0.08); }
  .site-item.active { background: rgba(79, 209, 197, 0.15); border-left: 3px solid var(--accent); }
  .site-name { font-weight: 500; font-size: 0.85rem; }
  .site-meta { color: var(--muted); font-size: 0.7rem; margin-top: 2px; }
  .site-score { font-size: 1rem; min-width: 70px; text-align: right; }

  .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; position: relative; }

  #map { flex: 1; min-height: 0; }

  /* Forecast overlay ‚Äî slides up from bottom */
  .forecast-wrapper { position: absolute; bottom: 0; left: 0; right: 0; height: 0; z-index: 10; display: flex; flex-direction: column; transition: height 0.3s ease; }
  .forecast-wrapper.open { height: 50%; }

  .drag-handle { height: 10px; background: var(--card); border-top: 1px solid var(--border); cursor: ns-resize; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
  .drag-handle::after { content: ''; width: 40px; height: 4px; background: var(--muted); border-radius: 2px; opacity: 0.5; }
  .drag-handle:hover::after { opacity: 1; }

  .forecast-panel { flex: 1; overflow-y: auto; padding: 1rem 1.5rem; background: var(--bg); min-height: 0; }

  /* Tuning panel */
  .tuning-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 1000; }
  .tuning-overlay.open { display: flex; justify-content: center; align-items: flex-start; padding-top: 60px; }
  .tuning-panel { background: var(--bg); border: 1px solid var(--border); border-radius: 12px; width: 700px; max-height: 80vh; overflow-y: auto; padding: 1.5rem; }
  .tuning-panel h2 { font-size: 1.2rem; margin-bottom: 1rem; display: flex; align-items: center; justify-content: space-between; }
  .tuning-section { margin-bottom: 1.25rem; }
  .tuning-section h3 { font-size: 0.85rem; color: var(--accent); text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.5rem; padding-bottom: 0.25rem; border-bottom: 1px solid var(--border); }
  .tuning-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem 1.5rem; }
  .tuning-field { display: flex; align-items: center; gap: 0.5rem; }
  .tuning-field label { flex: 1; font-size: 0.78rem; color: var(--muted); }
  .tuning-field input { width: 80px; background: var(--card); border: 1px solid var(--border); color: var(--text); padding: 0.3rem 0.5rem; border-radius: 4px; font-size: 0.8rem; text-align: right; }
  .tuning-field input:focus { outline: none; border-color: var(--accent); }
  .tuning-field input.changed { border-color: var(--warn); background: rgba(236,201,75,0.08); }
  .tuning-actions { display: flex; gap: 0.5rem; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border); }
  .tuning-actions button { padding: 0.5rem 1rem; border-radius: 6px; border: 1px solid var(--border); cursor: pointer; font-size: 0.85rem; }
  .btn-apply { background: var(--accent); color: var(--bg); border-color: var(--accent); font-weight: 600; }
  .btn-apply:hover { opacity: 0.9; }
  .btn-reset { background: transparent; color: var(--bad); border-color: var(--bad); }
  .btn-reset:hover { background: rgba(245,101,101,0.1); }
  .btn-close { background: transparent; color: var(--muted); }
  .btn-close:hover { color: var(--text); }
  .btn-export { background: transparent; color: var(--accent); border-color: var(--accent); }
  .btn-export:hover { background: rgba(79,209,197,0.1); }
  .tuning-badge { font-size: 0.65rem; background: var(--warn); color: var(--bg); padding: 0.1rem 0.4rem; border-radius: 8px; font-weight: 600; }

  .day-section { margin-bottom: 1.5rem; }
  .day-header { font-size: 1.1rem; font-weight: 600; padding: 0.5rem 0; border-bottom: 2px solid var(--border); margin-bottom: 0.5rem; display: flex; align-items: center; gap: 0.5rem; }
  .day-label { color: var(--accent); }

  .hour-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
  .hour-table th { text-align: left; color: var(--muted); font-weight: 500; padding: 0.35rem 0.5rem; border-bottom: 1px solid var(--border); white-space: nowrap; }
  .hour-table td { padding: 0.35rem 0.5rem; border-bottom: 1px solid rgba(45,55,72,0.5); white-space: nowrap; }
  .hour-table tr:hover { background: rgba(79, 209, 197, 0.05); }

  .stars { letter-spacing: -2px; }
  .gradient-low { color: var(--good); }
  .gradient-med { color: var(--warn); }
  .gradient-high { color: var(--bad); }
  .rain { color: #63b3ed; }

  .summary-cards { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 0.6rem; margin-top: 0.6rem; }
  .summary-card { background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 0.6rem; }
  .summary-card .label { color: var(--muted); font-size: 0.7rem; text-transform: uppercase; margin-bottom: 0.2rem; }
  .summary-card .value { font-size: 1.1rem; font-weight: 600; }

  .extended-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
  .extended-table th { text-align: left; color: var(--muted); font-weight: 500; padding: 0.5rem; border-bottom: 1px solid var(--border); }
  .extended-table td { padding: 0.5rem; border-bottom: 1px solid rgba(45,55,72,0.5); }

  .status-bar { position: fixed; bottom: 0; left: 0; right: 0; padding: 0.4rem 1rem; background: var(--card); border-top: 1px solid var(--border); font-size: 0.7rem; color: var(--muted); z-index: 20; }

  .spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid var(--muted); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
  @keyframes spin { to { transform: rotate(360deg); } }

  @media (max-width: 768px) {
    .layout { flex-direction: column; }
    .sidebar { width: 100%; height: auto; max-height: 160px; border-right: none; border-bottom: 1px solid var(--border); }
    .forecast-wrapper.open { height: 60%; }
    .tuning-panel { width: 95%; margin: 0 auto; }
    .tuning-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<div class="header">
  <h1><span>ü™Ç</span> PG Forecast</h1>
  <div id="wasmStatus" style="font-size: 0.8rem; color: var(--muted);"><span class="spinner"></span> Loading WASM‚Ä¶</div>
  <div class="header-actions">
    <button class="header-btn" id="tuningBtn" onclick="toggleTuning()">‚öôÔ∏è Tuning</button>
  </div>
</div>

<div class="tuning-overlay" id="tuningOverlay" onclick="if(event.target===this)closeTuning()">
  <div class="tuning-panel" id="tuningPanel"></div>
</div>

<div class="layout">
  <div class="sidebar">
    <div class="sidebar-header">Sites</div>
    <div id="siteList"></div>
  </div>
  <div class="main">
    <div id="map"></div>
    <div class="forecast-wrapper" id="forecastWrapper">
      <div class="drag-handle" id="dragHandle"></div>
      <div class="forecast-panel" id="forecastPanel"></div>
    </div>
  </div>
</div>

<div class="status-bar" id="statusBar">Ready</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="wasm_exec.js"></script>
<script>
// === Drag handle for forecast panel ===
(function() {
  const handle = document.getElementById('dragHandle');
  const wrapper = document.getElementById('forecastWrapper');
  const main = document.querySelector('.main');
  let dragging = false;
  let startY, startH;

  handle.addEventListener('mousedown', (e) => {
    dragging = true;
    startY = e.clientY;
    startH = wrapper.offsetHeight;
    wrapper.style.transition = 'none';
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!dragging) return;
    const mainRect = main.getBoundingClientRect();
    const minH = 80;
    const maxH = mainRect.height - 60;
    let newH = startH + (startY - e.clientY);
    newH = Math.max(minH, Math.min(maxH, newH));
    wrapper.style.height = newH + 'px';
    map.invalidateSize();
  });

  document.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = false;
    wrapper.style.transition = '';
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
    map.invalidateSize();
  });

  // Touch support
  handle.addEventListener('touchstart', (e) => {
    dragging = true;
    startY = e.touches[0].clientY;
    startH = wrapper.offsetHeight;
    wrapper.style.transition = 'none';
    e.preventDefault();
  }, { passive: false });

  document.addEventListener('touchmove', (e) => {
    if (!dragging) return;
    const mainRect = main.getBoundingClientRect();
    const minH = 80;
    const maxH = mainRect.height - 60;
    let newH = startH + (startY - e.touches[0].clientY);
    newH = Math.max(minH, Math.min(maxH, newH));
    wrapper.style.height = newH + 'px';
    map.invalidateSize();
  }, { passive: false });

  document.addEventListener('touchend', () => {
    if (!dragging) return;
    dragging = false;
    wrapper.style.transition = '';
    map.invalidateSize();
  });
})();

function showForecastPanel() {
  const wrapper = document.getElementById('forecastWrapper');
  if (!wrapper.classList.contains('open')) {
    wrapper.classList.add('open');
    wrapper.style.height = '';  // reset to CSS default (50%)
    setTimeout(() => map.invalidateSize(), 350);
  }
}

function hideForecastPanel() {
  const wrapper = document.getElementById('forecastWrapper');
  wrapper.classList.remove('open');
  wrapper.style.height = '';
  document.getElementById('forecastPanel').innerHTML = '';
  setTimeout(() => map.invalidateSize(), 350);
}

// === Tuning system ===
const TUNING_STORAGE_KEY = 'pgforecast_tuning';
let defaultTuning = null;
let activeTuning = null;

const TUNING_LABELS = {
  wind: {
    _title: 'Wind',
    ideal_min: 'Ideal min (mph)',
    ideal_max: 'Ideal max (mph)',
    acceptable_min: 'Acceptable min (mph)',
    acceptable_max: 'Acceptable max (mph)',
    dangerous_max: 'Dangerous max (mph)',
    max_gust_factor: 'Max gust factor',
    dangerous_gust_factor: 'Dangerous gust factor',
  },
  gradient: {
    _title: 'Wind Gradient',
    low_threshold: 'Low threshold (mph diff)',
    high_threshold: 'High threshold (mph diff)',
    high_penalty: 'High penalty',
    medium_penalty: 'Medium penalty',
  },
  thermal: {
    _title: 'Thermals',
    cape_weak: 'CAPE weak (J/kg)',
    cape_moderate: 'CAPE moderate',
    cape_strong: 'CAPE strong',
    cape_extreme: 'CAPE extreme',
    lapse_rate_bonus: 'Lapse rate bonus (¬∞C/km)',
  },
  orographic: {
    _title: 'Orographic Lift',
    min_wind_speed: 'Min wind speed (mph)',
    strong_angle: 'Strong angle (¬∞)',
    moderate_angle: 'Moderate angle (¬∞)',
    weak_angle: 'Weak angle (¬∞)',
  },
  cloudbase: {
    _title: 'Cloudbase',
    min_realistic_ft: 'Min realistic (ft)',
  },
  scoring: {
    _title: 'Flyability Scoring',
    base_score: 'Base score',
    wind_ideal_bonus: 'Wind ideal bonus',
    wind_acceptable_bonus: 'Wind acceptable bonus',
    wind_danger_penalty: 'Wind danger penalty',
    wind_high_penalty: 'Wind high penalty',
    dir_on_bonus: 'Direction on-site bonus',
    dir_off_penalty: 'Direction off-site penalty',
    gust_high_penalty: 'Gust high penalty',
    gust_med_penalty: 'Gust medium penalty',
    rain_penalty: 'Rain penalty',
    rain_prob_penalty: 'Rain probability penalty',
    gradient_high_penalty: 'Gradient high penalty',
    gradient_med_penalty: 'Gradient medium penalty',
    cape_bonus: 'CAPE bonus',
    thermal_strong_bonus: 'Thermal strong bonus',
  },
  xc: {
    _title: 'XC Potential',
    min_cloudbase_ft: 'Min cloudbase (ft)',
    good_cloudbase_ft: 'Good cloudbase (ft)',
    max_wind_speed: 'Max wind speed (mph)',
    min_wind_speed: 'Min wind speed (mph)',
    epic_threshold: 'Epic threshold',
    high_threshold: 'High threshold',
    medium_threshold: 'Medium threshold',
  },
};

async function loadTuning() {
  try {
    const resp = await fetch('tuning.json');
    defaultTuning = await resp.json();
  } catch (e) {
    if (wasmReady) defaultTuning = JSON.parse(pgforecastWasm.defaultTuning());
  }
  const stored = localStorage.getItem(TUNING_STORAGE_KEY);
  if (stored) {
    try { activeTuning = JSON.parse(stored); updateTuningBadge(true); }
    catch (e) { activeTuning = JSON.parse(JSON.stringify(defaultTuning)); }
  } else {
    activeTuning = JSON.parse(JSON.stringify(defaultTuning));
  }
}

function getTuningJSON() { return JSON.stringify(activeTuning); }
function hasCustomTuning() { return JSON.stringify(activeTuning) !== JSON.stringify(defaultTuning); }

function updateTuningBadge(custom) {
  const btn = document.getElementById('tuningBtn');
  if (custom) { btn.classList.add('active'); btn.innerHTML = '‚öôÔ∏è Tuning <span class="tuning-badge">CUSTOM</span>'; }
  else { btn.classList.remove('active'); btn.textContent = '‚öôÔ∏è Tuning'; }
}

function toggleTuning() {
  const o = document.getElementById('tuningOverlay');
  o.classList.contains('open') ? closeTuning() : openTuning();
}
function openTuning() { renderTuningPanel(); document.getElementById('tuningOverlay').classList.add('open'); }
function closeTuning() { document.getElementById('tuningOverlay').classList.remove('open'); }

function renderTuningPanel() {
  const panel = document.getElementById('tuningPanel');
  let html = `<h2>‚öôÔ∏è Scoring Parameters <button class="btn-close" onclick="closeTuning()">‚úï</button></h2>`;
  for (const [section, labels] of Object.entries(TUNING_LABELS)) {
    html += `<div class="tuning-section"><h3>${labels._title}</h3><div class="tuning-grid">`;
    for (const [key, label] of Object.entries(labels)) {
      if (key === '_title') continue;
      const val = activeTuning[section][key], def = defaultTuning[section][key];
      html += `<div class="tuning-field"><label title="Default: ${def}">${label}</label>
        <input type="number" step="any" value="${val}" data-section="${section}" data-key="${key}"
               class="${val !== def ? 'changed' : ''}" onchange="onTuningInput(this)" /></div>`;
    }
    html += `</div></div>`;
  }
  html += `<div class="tuning-actions">
    <button class="btn-apply" onclick="applyTuning()">Apply & Rescore</button>
    <button class="btn-reset" onclick="resetTuning()">Reset to Defaults</button>
    <button class="btn-export" onclick="exportTuning()">üìã Export JSON</button>
    <button class="btn-close" onclick="importTuning()">üìÇ Import JSON</button></div>`;
  panel.innerHTML = html;
}

function onTuningInput(el) {
  const val = parseFloat(el.value); if (isNaN(val)) return;
  activeTuning[el.dataset.section][el.dataset.key] = val;
  el.classList.toggle('changed', val !== defaultTuning[el.dataset.section][el.dataset.key]);
}

function applyTuning() {
  if (hasCustomTuning()) { localStorage.setItem(TUNING_STORAGE_KEY, JSON.stringify(activeTuning)); updateTuningBadge(true); }
  else { localStorage.removeItem(TUNING_STORAGE_KEY); updateTuningBadge(false); }
  const cached = {}; for (const [n, fc] of Object.entries(siteForecasts)) { if (fc._weatherJSON) cached[n] = fc._weatherJSON; }
  siteForecasts = {}; rescoreAll(cached); closeTuning(); setStatus('Tuning applied ‚Äî rescoring‚Ä¶');
}

function resetTuning() {
  activeTuning = JSON.parse(JSON.stringify(defaultTuning)); localStorage.removeItem(TUNING_STORAGE_KEY); updateTuningBadge(false);
  renderTuningPanel();
  const cached = {}; for (const [n, fc] of Object.entries(siteForecasts)) { if (fc._weatherJSON) cached[n] = fc._weatherJSON; }
  siteForecasts = {}; rescoreAll(cached); setStatus('Reset to defaults ‚Äî rescored');
}

function exportTuning() {
  const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([JSON.stringify(activeTuning, null, 2)], { type: 'application/json' }));
  a.download = 'pgforecast-tuning.json'; a.click();
}

function importTuning() {
  const input = document.createElement('input'); input.type = 'file'; input.accept = '.json';
  input.onchange = async (e) => {
    const file = e.target.files[0]; if (!file) return;
    try {
      const imported = JSON.parse(await file.text());
      for (const s of Object.keys(TUNING_LABELS)) { if (!imported[s]) throw new Error(`Missing: ${s}`); }
      activeTuning = imported; renderTuningPanel(); setStatus('Imported ‚Äî click Apply');
    } catch (err) { alert('Invalid: ' + err.message); }
  }; input.click();
}

async function rescoreAll(cachedWeather) {
  for (const site of SITES) {
    try {
      const wj = cachedWeather[site.name] || await fetchWeather(site);
      const r = JSON.parse(pgforecastWasm.computeMetrics(wj, JSON.stringify(site), getTuningJSON()));
      if (!r.error) {
        const days = groupByDay(r); let best = 0;
        days.slice(0,3).forEach(d => d.hours.forEach(h => { if (h.flyability_score > best) best = h.flyability_score; }));
        siteForecasts[site.name] = { site, days, bestScore: best, _weatherJSON: wj };
        updateMarkerColor(site.name, best);
      }
    } catch (e) {}
    renderSiteList();
  }
  if (selectedSite && siteForecasts[selectedSite]) renderForecast(siteForecasts[selectedSite]);
  setStatus('All sites rescored');
}

// === Sites ===
let SITES = [];

// === Open-Meteo API ===
const PRESSURE_LEVELS = [1000, 950, 925, 900, 850, 700];
const SURFACE_PARAMS = [
  'temperature_2m','relative_humidity_2m','dew_point_2m','wind_speed_10m','wind_direction_10m','wind_gusts_10m',
  'cloud_cover','cloud_cover_low','cloud_cover_mid','cloud_cover_high','cape','shortwave_radiation',
  'precipitation','precipitation_probability','freezing_level_height','is_day','weather_code','pressure_msl','visibility',
];

function buildOpenMeteoURL(lat, lon) {
  const pp = PRESSURE_LEVELS.flatMap(p => [`wind_speed_${p}hPa`,`wind_direction_${p}hPa`,`temperature_${p}hPa`,`geopotential_height_${p}hPa`]);
  return `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=${[...SURFACE_PARAMS,...pp].join(',')}&wind_speed_unit=mph&forecast_days=16&timezone=UTC`;
}

async function fetchWeather(site) {
  const r = await fetch(buildOpenMeteoURL(site.lat, site.lon));
  if (!r.ok) throw new Error(`API ${r.status}`);
  return await r.text();
}

// === WASM ===
let wasmReady = false;
async function loadWasm() {
  const go = new Go();
  const result = await WebAssembly.instantiateStreaming(fetch('pgforecast.wasm'), go.importObject);
  go.run(result.instance);
  wasmReady = true;
  document.getElementById('wasmStatus').innerHTML = '‚úÖ WASM ready';
}

// === Map ===
let map, markers = {};
function initMap() {
  map = L.map('map').setView([50.78, -2.2], 10);
  L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    attribution: '¬© OpenStreetMap ¬© CARTO', maxZoom: 18
  }).addTo(map);

  SITES.forEach(site => {
    const marker = L.circleMarker([site.lat, site.lon], {
      radius: 6, fillColor: '#718096', color: '#2d3748', weight: 2, fillOpacity: 0.7
    }).addTo(map);
    marker.bindTooltip(site.name, { direction: 'top', offset: [0, -10] });
    marker.on('click', (e) => { L.DomEvent.stopPropagation(e); selectSite(site.name); });
    markers[site.name] = marker;
  });

  map.on('click', () => {
    if (selectedSite) {
      selectedSite = null;
      renderSiteList();
      hideForecastPanel();
    }
  });
}

function updateMarkerColor(name, score) {
  const colors = { 1: '#f56565', 2: '#ed8936', 3: '#ecc94b', 4: '#48bb78', 5: '#38b2ac' };
  const radii = { 1: 6, 2: 7, 3: 8, 4: 9, 5: 10 };
  const m = markers[name];
  if (m) { m.setStyle({ fillColor: colors[score] || '#718096', fillOpacity: score >= 4 ? 0.9 : 0.7 }); m.setRadius(radii[score] || 6); }
}

// === UI ===
let selectedSite = null;
let siteForecasts = {};

function compassDir(deg) {
  const d = ['N','NNE','NE','ENE','E','ESE','SE','SSE','S','SSW','SW','WSW','W','WNW','NW','NNW'];
  return d[Math.round(deg / 22.5) % 16];
}
function starsHTML(n) { return '‚≠ê'.repeat(n); }
function gradientClass(g) { return g.includes('Low') ? 'gradient-low' : g.includes('Medium') ? 'gradient-med' : 'gradient-high'; }
function gradientIcon(g) { return g.includes('Low') ? '‚úÖ' : g.includes('Medium') ? '‚ö†Ô∏è' : 'üî¥'; }
function thermalIcon(t) { return { None:'‚ùÑÔ∏è', Weak:'üå§', Moderate:'‚òÄÔ∏è', Strong:'üî•', Extreme:'‚ö°' }[t] || '‚ùì'; }
function cloudIcon(c) { return c < 20 ? '‚òÄÔ∏è' : c < 50 ? '‚õÖ' : c < 80 ? 'üå•' : '‚òÅÔ∏è'; }
function rainStr(p, prob) { return p > 0 ? `<span class="rain">üåß${p.toFixed(1)}</span>` : prob > 30 ? `${prob.toFixed(0)}%` : '-'; }

function renderSiteList() {
  document.getElementById('siteList').innerHTML = SITES.map(s => {
    const fc = siteForecasts[s.name];
    return `<div class="site-item ${selectedSite === s.name ? 'active' : ''}" onclick="selectSite('${s.name}')">
      <div><div class="site-name">${s.name}</div>
      <div class="site-meta">${compassDir(s.aspect)} facing ¬∑ ${s.elevation}m</div></div>
      <div class="site-score">${fc ? starsHTML(fc.bestScore) : ''}</div></div>`;
  }).join('');
}

async function selectSite(name) {
  selectedSite = name;
  renderSiteList();
  const site = SITES.find(s => s.name === name);
  if (!site) return;
  map.flyTo([site.lat, site.lon], 12, { duration: 0.5 });

  showForecastPanel();
  const panel = document.getElementById('forecastPanel');

  if (siteForecasts[name]) { renderForecast(siteForecasts[name]); return; }

  panel.innerHTML = '<p style="text-align:center;padding:2rem;"><span class="spinner"></span> Fetching forecast‚Ä¶</p>';
  setStatus(`Fetching weather for ${name}‚Ä¶`);

  try {
    const wj = await fetchWeather(site);
    if (!wasmReady) { panel.innerHTML = '<p style="color:var(--bad);text-align:center;padding:2rem;">WASM not loaded</p>'; return; }
    const r = JSON.parse(pgforecastWasm.computeMetrics(wj, JSON.stringify(site), getTuningJSON()));
    if (r.error) { panel.innerHTML = `<p style="color:var(--bad);text-align:center;padding:2rem;">${r.error}</p>`; return; }
    const days = groupByDay(r);
    const fc = { site, days, bestScore: 0, _weatherJSON: wj };
    days.forEach(d => d.hours.forEach(h => { if (h.flyability_score > fc.bestScore) fc.bestScore = h.flyability_score; }));
    siteForecasts[name] = fc;
    updateMarkerColor(name, fc.bestScore);
    renderSiteList();
    renderForecast(fc);
    setStatus(`${name} loaded`);
  } catch (err) {
    panel.innerHTML = `<p style="color:var(--bad);text-align:center;padding:2rem;">${err.message}</p>`;
    setStatus(`Error: ${err.message}`);
  }
}

function groupByDay(metrics) {
  const m = {}, o = [];
  metrics.forEach(h => {
    const dt = new Date(h.time), k = dt.toISOString().slice(0,10), hr = dt.getUTCHours();
    if (hr < 8 || hr > 18) return;
    if (!m[k]) { m[k] = []; o.push(k); }
    m[k].push(h);
  });
  return o.map(k => ({ date: k, hours: m[k] }));
}

function renderForecast(forecast) {
  const panel = document.getElementById('forecastPanel');
  const days = forecast.days, detailed = days.slice(0,3), extended = days.slice(3);
  let html = `<h2 style="margin-bottom:1rem;font-size:1.2rem;">${forecast.site.name}</h2>`;

  detailed.forEach((day, i) => {
    const dt = new Date(day.date + 'T12:00:00Z');
    const label = i === 0 ? 'TODAY' : i === 1 ? 'TOMORROW' : dt.toLocaleDateString('en-GB', { weekday:'short', day:'numeric', month:'short' });
    const dayLabel = dt.toLocaleDateString('en-GB', { weekday:'short', day:'numeric', month:'short' });
    const mid = day.hours[Math.floor(day.hours.length/2)] || day.hours[0];
    const best = Math.max(...day.hours.map(h => h.flyability_score));
    const cb = mid ? Math.round(mid.cloudbase_ft || 0) : 0;

    html += `<div class="day-section">
      <div class="day-header"><span class="day-label">${label}</span> ${dayLabel}</div>
      <div class="summary-cards">
        <div class="summary-card"><div class="label">Best Score</div><div class="value">${starsHTML(best)}</div></div>
        <div class="summary-card"><div class="label">Cloudbase</div><div class="value">${cb <= 200 ? 'Fog' : cb + 'ft'}</div></div>
        <div class="summary-card"><div class="label">CAPE</div><div class="value">${mid ? mid.cape.toFixed(0) : 0} J/kg</div></div>
        <div class="summary-card"><div class="label">XC Potential</div><div class="value">${mid ? mid.xc_potential : 'N/A'}</div></div>
      </div>
      <table class="hour-table"><tr><th>Time</th><th>Wind</th><th>Dir</th><th>Gust</th><th>Gradient</th><th>Thermal</th><th>Cloud</th><th>Rain</th><th>Score</th></tr>
      ${day.hours.map(h => {
        const t = new Date(h.time);
        return `<tr><td>${t.getUTCHours().toString().padStart(2,'0')}:00</td>
          <td>${h.wind_speed.toFixed(0)}mph</td><td>${h.wind_dir_str}</td><td>${h.wind_gusts.toFixed(0)}</td>
          <td class="${gradientClass(h.wind_gradient)}">${gradientIcon(h.wind_gradient)} ${h.wind_gradient}(+${h.wind_gradient_diff.toFixed(0)})</td>
          <td>${thermalIcon(h.thermal_rating)} ${h.thermal_rating}</td>
          <td>${cloudIcon(h.cloud_cover)}</td><td>${rainStr(h.precipitation, h.precip_probability)}</td>
          <td class="stars">${starsHTML(h.flyability_score)}</td></tr>`;
      }).join('')}</table></div>`;
  });

  if (extended.length > 0) {
    html += `<div class="day-section"><div class="day-header"><span class="day-label">EXTENDED OUTLOOK</span></div>
      <table class="extended-table"><tr><th>Day</th><th>Wind</th><th>Dir</th><th>Thermal</th><th>Rain</th><th>Score</th></tr>
      ${extended.map(day => {
        const dt = new Date(day.date + 'T12:00:00Z');
        const ds = dt.toLocaleDateString('en-GB', { weekday:'short', day:'numeric', month:'short' });
        const aw = day.hours.reduce((s,h)=>s+h.wind_speed,0)/day.hours.length;
        const ad = day.hours.reduce((s,h)=>s+h.wind_direction,0)/day.hours.length;
        const mp = Math.max(...day.hours.map(h=>h.precip_probability));
        const bt = ['None','Weak','Moderate','Strong','Extreme'][Math.max(...day.hours.map(h=>['None','Weak','Moderate','Strong','Extreme'].indexOf(h.thermal_rating)))];
        const sc = day.hours.map(h=>h.flyability_score).sort((a,b)=>b-a);
        const avg = Math.round(sc.slice(0,3).reduce((a,b)=>a+b,0)/Math.min(3,sc.length));
        return `<tr><td>${ds}</td><td>${aw.toFixed(0)}mph</td><td>${compassDir(ad)}</td>
          <td>${thermalIcon(bt)} ${bt}</td><td>${mp.toFixed(0)}%</td><td class="stars">${starsHTML(avg)}</td></tr>`;
      }).join('')}</table></div>`;
  }
  panel.innerHTML = html;
}

function setStatus(msg) { document.getElementById('statusBar').textContent = msg; }

// === Load all sites ===
async function loadAllSitesOverview() {
  setStatus('Loading all sites‚Ä¶');
  for (const site of SITES) {
    try {
      const wj = await fetchWeather(site);
      const r = JSON.parse(pgforecastWasm.computeMetrics(wj, JSON.stringify(site), getTuningJSON()));
      if (!r.error) {
        const days = groupByDay(r); let best = 0;
        days.slice(0,3).forEach(d => d.hours.forEach(h => { if (h.flyability_score > best) best = h.flyability_score; }));
        siteForecasts[site.name] = { site, days, bestScore: best, _weatherJSON: wj };
        updateMarkerColor(site.name, best);
      }
    } catch (e) {}
    renderSiteList();
    setStatus(`Loaded ${site.name}`);
  }
  setStatus('All sites loaded');
}

// === Init ===
async function init() {
  try { SITES = await (await fetch('sites.json')).json(); }
  catch (e) { setStatus('Failed to load sites.json: ' + e.message); return; }
  initMap();
  renderSiteList();
  try { await loadWasm(); await loadTuning(); loadAllSitesOverview(); }
  catch (err) { document.getElementById('wasmStatus').innerHTML = `‚ùå WASM error: ${err.message}`; }
}
init();
</script>
</body>
</html>
